#include <iostream>
using namespace std;
struct Node {
    int data, count;
    Node *left, *right;
};
Node* createNode(int value) {
    Node* newNode = new Node;
    newNode->data = value;
    newNode->count = 1;
    newNode->left = newNode->right = nullptr;
    return newNode;
}
Node* insert(Node* root, int value) {
    if (root == nullptr)
        return createNode(value);
    if (value < root->data)
        root->left = insert(root->left, value);
    else if (value > root->data)
        root->right = insert(root->right, value);
    else
        root->count++;
    return root;
}
Node* minValueNode(Node* node) {
    Node* current = node;
    while (current && current->left != nullptr)
        current = current->left;
    return current;
}
Node* deleteNode(Node* root, int value) {
    if (root == nullptr)
        return root;
    if (value < root->data)
        root->left = deleteNode(root->left, value);
    else if (value > root->data)
        root->right = deleteNode(root->right, value);
    else {
        if (root->count > 1) {
            root->count--;
            return root;
        }
        if (root->left == nullptr) {
            Node* temp = root->right;
            delete root;
            return temp;
        } else if (root->right == nullptr) {
            Node* temp = root->left;
            delete root;
            return temp;
        }
        Node* temp = minValueNode(root->right);
        root->data = temp->data;
        root->count = temp->count;
        temp->count = 1;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}
Node* search(Node* root, int value) {
    if (root == nullptr || root->data == value)
        return root;
    if (value < root->data)
        return search(root->left, value);
    return search(root->right, value);
}
void inorder(Node* root) {
    if (root != nullptr) {
        inorder(root->left);
        cout << root->data << "(" << root->count << ") ";
        inorder(root->right);
    }
}
void preorder(Node* root) {
    if (root != nullptr) {
        cout << root->data << "(" << root->count << ") ";
        preorder(root->left);
        preorder(root->right);
    }
}
void postorder(Node* root) {
    if (root != nullptr) {
        postorder(root->left);
        postorder(root->right);
        cout << root->data << "(" << root->count << ") ";
    }
}
int depth(Node* root) {
    if (root == nullptr) return 0;
    int leftDepth = depth(root->left);
    int rightDepth = depth(root->right);
    return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
}
void mirror(Node* root) {
    if (root == nullptr) return;
    Node* temp = root->left;
    root->left = root->right;
    root->right = temp;
    mirror(root->left);
    mirror(root->right);
}
Node* copyTree(Node* root) {
    if (root == nullptr) return nullptr;
    Node* newNode = createNode(root->data);
    newNode->count = root->count;
    newNode->left = copyTree(root->left);
    newNode->right = copyTree(root->right);
    return newNode;
}
void showParentChild(Node* root) {
    if (root == nullptr) return;
    if (root->left != nullptr)
        cout << "Parent " << root->data << " -> Left Child " << root->left->data << endl;
    if (root->right != nullptr)
        cout << "Parent " << root->data << " -> Right Child " << root->right->data << endl;
    showParentChild(root->left);
    showParentChild(root->right);
}
void showLeaves(Node* root) {
    if (root == nullptr) return;
    if (root->left == nullptr && root->right == nullptr)
        cout << root->data << " ";
    showLeaves(root->left);
    showLeaves(root->right);
}
void levelOrder(Node* root) {
    if (root == nullptr) return;
    Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;
    while (front < rear) {
        Node* current = queue[front++];
        cout << current->data << " ";
        if (current->left != nullptr) queue[rear++] = current->left;
        if (current->right != nullptr) queue[rear++] = current->right;
    }
}
int main() {
    Node* root = nullptr;
    Node* copiedTree = nullptr;
    int choice, value;
    do {
        cout << "\n--- Binary Search Tree Menu ---\n";
        cout << "1. Insert Node\n";
        cout << "2. Delete Node\n";
        cout << "3. Search Node\n";
        cout << "4. Display (Inorder, Preorder, Postorder)\n";
        cout << "5. Show Depth of Tree\n";
        cout << "6. Show Mirror Image\n";
        cout << "7. Create Copy of Tree\n";
        cout << "8. Show Parent and Child Nodes\n";
        cout << "9. Show Leaf Nodes\n";
        cout << "10. Show Level-wise Display\n";
        cout << "11. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;
        switch (choice) {
            case 1:
                cout << "Enter value to insert: ";
                cin >> value;
                root = insert(root, value);
                break;
            case 2:
                cout << "Enter value to delete: ";
                cin >> value;
                root = deleteNode(root, value);
                break;
            case 3:
                cout << "Enter value to search: ";
                cin >> value;
                if (search(root, value))
                    cout << "Value found in tree.\n";
                else
                    cout << "Value not found.\n";
                break;
            case 4:
                cout << "Inorder: "; inorder(root); cout << endl;
                cout << "Preorder: "; preorder(root); cout << endl;
                cout << "Postorder: "; postorder(root); cout << endl;
                break;
            case 5:
                cout << "Depth of tree: " << depth(root) << endl;
                break;
            case 6:
                mirror(root);
                cout << "Mirror image created. Inorder display:\n";
                inorder(root); cout << endl;
                break;
            case 7:
                copiedTree = copyTree(root);
                cout << "Tree copied successfully.\n";
                break;
            case 8:
                cout << "Parent and their children:\n";
                showParentChild(root);
                break;
            case 9:
                cout << "Leaf nodes: ";
                showLeaves(root);
                cout << endl;
                break;
            case 10:
                cout << "Level-wise display: ";
                levelOrder(root);
                cout << endl;
                break;
            case 11:
                cout << "Exiting program.\n";
                break;
            default:
                cout << "Invalid choice. Try again.\n";
        }
    } while (choice != 11);
    return 0;
}
